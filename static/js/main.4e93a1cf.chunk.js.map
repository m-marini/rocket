{"version":3,"sources":["modules/SceneComponent.tsx","modules/MenuBar.tsx","modules/ImportFile.tsx","modules/Home.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["SceneComponent","props","reactCanvas","useRef","antialias","engineOptions","adaptToDeviceRatio","sceneOptions","onRender","renderChildrenWhenReady","onSceneReady","children","rest","useState","scene","sceneReady","sceneContext","setSceneContext","engine","canvas","engineContext","setEngineContext","useEffect","current","Engine","Scene","sceneIsReady","isReady","onReadyObservable","addOnce","runRenderLoop","activeCamera","render","console","warn","resize","getEngine","window","addEventListener","dispose","removeEventListener","ref","Provider","value","MenuBar","onImport","onReplay","Navbar","variant","bg","expand","Brand","href","Toggle","aria-controls","Collapse","id","Nav","className","Link","process","onClick","ImportFile","file","this","onFileRead","onError","fr","FileReader","onload","e","result","onerror","event","error","toString","readAsText","show","onCancel","Modal","size","onHide","Header","closeButton","Title","Body","Form","File","label","custom","onChange","ev","onFileChange","target","files","Footer","Button","Component","PlatformRatio","Viewpoint","Vector3","Path","SceneStatus","_t","_sampleInterval","_path","path","t","sampleInterval","Zero","n","length","nt","i","Math","floor","dl","p0","subtract","scale","add","dt","status","createStatus","camera","FollowCamera","radius","heightOffset","cameraAcceleration","maxCameraSpeed","createCamera1","camera2","UniversalCamera","attachControl","createCamera2","viewport","Viewport","activeCameras","push","light","HemisphericLight","intensity","buildLights","groundMat","StandardMaterial","diffuseTexture","Texture","ground","MeshBuilder","CreateGround","width","height","subdivisions","material","position","y","buildGround","platMat","platform","receiveShadows","buildPlatform","skybox","CreateBox","skyboxMaterial","backFaceCulling","reflectionTexture","CubeTexture","coordinatesMode","SKYBOX_MODE","diffuseColor","Color3","specularColor","buildSkybox","SceneLoader","ImportMesh","meshes","particles","skeletons","rocket","camera1","getCameraByName","name","lockedTarget","onRocketLoad","loadRocket","Home","state","importModalShown","setState","data","log","Container","fluid","showImportPanel","reset","dt1","getDeltaTime","last","getMeshByName","onImportCancel","onImportFile","onImportError","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.4e93a1cf.chunk.js","sourcesContent":["import React, { useEffect, useContext, useRef, useState, FunctionComponent } from 'react';\nimport { Engine, Scene, Nullable, EngineOptions, SceneOptions, EventState, Observer, Camera } from '@babylonjs/core';\nimport { EngineCanvasContext, EngineCanvasContextType, SceneContext, SceneContextType } from 'babylonjs-hook';\nimport '../App.css';\n\nexport type BabylonjsProps = {\n    antialias?: boolean\n    engineOptions?: EngineOptions\n    adaptToDeviceRatio?: boolean\n    renderChildrenWhenReady?: boolean\n    sceneOptions?: SceneOptions\n    onSceneReady: (scene: Scene) => void\n    onRender?: (scene: Scene) => void\n    id: string\n    children?: React.ReactNode\n    width?: number;\n    height?: number;\n};\n\nexport type OnFrameRenderFn = (eventData: Scene, eventState: EventState) => void\n\n/**\n * Register a callback for before the scene renders.\n * \n * @param callback called using onBeforeRender functionality of scene\n * @param mask the mask used to filter observers\n * @param insertFirst if true will be inserted at first position, if false (default) will be last position.\n * @param callOnce only call the callback once\n */\nexport const useBeforeRender = (callback: OnFrameRenderFn, mask?: number, insertFirst?: boolean, callOnce?: boolean): void => {\n    const { scene } = useContext(SceneContext);\n\n    useEffect(() => {\n        if (scene === null) {\n            return;\n        }\n\n        const unregisterOnFirstCall: boolean = callOnce === true;\n        const sceneObserver: Nullable<Observer<Scene>> = scene.onBeforeRenderObservable.add(callback, mask, insertFirst, undefined, unregisterOnFirstCall);\n\n        if (unregisterOnFirstCall !== true) {\n            return () => {\n                scene.onBeforeRenderObservable.remove(sceneObserver);\n            }\n        }\n    })\n}\n\n/**\n * Register a callback for after the scene renders.\n * \n * @param callback called using onBeforeRender functionality of scene\n * @param mask the mask used to filter observers\n * @param insertFirst if true will be inserted at first position, if false (default) will be last position.\n * @param callOnce only call the callback once\n */\nexport const useAfterRender = (callback: OnFrameRenderFn, mask?: number, insertFirst?: boolean, callOnce?: boolean): void => {\n    const { scene } = useContext(SceneContext);\n\n    useEffect(() => {\n        if (scene === null) {\n            return;\n        }\n\n        const unregisterOnFirstCall: boolean = callOnce === true;\n        const sceneObserver: Nullable<Observer<Scene>> = scene.onAfterRenderObservable.add(callback, mask, insertFirst, undefined, unregisterOnFirstCall);\n\n        if (unregisterOnFirstCall !== true) {\n            return () => {\n                scene.onAfterRenderObservable.remove(sceneObserver);\n            }\n        }\n    })\n}\n\n/**\n * Handles creating a camera and attaching/disposing.\n * TODO: add new 4.2 parameters: useCtrlForPanning & panningMouseButton\n * @param createCameraFn function that creates and returns a camera\n * @param autoAttach Attach the input controls (default true)\n * @param noPreventDefault Events caught by controls should call prevent default\n */\nexport const useCamera = <T extends Camera>(createCameraFn: (scene: Scene) => T, autoAttach: boolean = true, noPreventDefault: boolean = true): Nullable<T> => {\n    const { scene } = useContext(SceneContext);\n    const cameraRef = useRef<Nullable<T>>(null);\n\n    useEffect(() => {\n        if (scene === null) {\n            console.warn('cannot create camera (scene not ready)');\n            return;\n        }\n\n        const camera = createCameraFn(scene);\n        if (autoAttach === true) {\n            const canvas: HTMLCanvasElement = scene.getEngine()!.getRenderingCanvas()!;\n\n            // This attaches the camera to the canvas\n            // https://github.com/BabylonJS/Babylon.js/pull/9192 (keep canvas to work with < 4.2 beta-13)\n            (camera as any).attachControl(canvas, noPreventDefault);\n        }\n        cameraRef.current = camera;\n\n        return () => {\n            if (autoAttach === true) {\n                const canvas: HTMLCanvasElement = scene.getEngine()!.getRenderingCanvas()!;\n                (camera as any).detachControl(canvas);\n            }\n            camera.dispose();\n        }\n    }, [scene, autoAttach, createCameraFn, noPreventDefault]);\n\n    return cameraRef.current;\n}\n\nexport const SceneComponent: FunctionComponent<BabylonjsProps> = props => {\n    const reactCanvas = useRef<Nullable<HTMLCanvasElement>>(null);\n    const { antialias, engineOptions, adaptToDeviceRatio, sceneOptions, onRender, onSceneReady, renderChildrenWhenReady, children, ...rest } = props;\n\n    const [sceneContext, setSceneContext] = useState<SceneContextType>({\n        scene: null,\n        sceneReady: false\n    });\n\n    const [engineContext, setEngineContext] = useState<EngineCanvasContextType>({\n        engine: null,\n        canvas: null\n    });\n\n    useEffect(() => {\n        if (reactCanvas.current) {\n            const engine = new Engine(reactCanvas.current, antialias, engineOptions, adaptToDeviceRatio);\n            setEngineContext(() => ({\n                engine,\n                canvas: reactCanvas.current\n            }));\n\n            const scene = new Scene(engine, sceneOptions);\n            const sceneIsReady = scene.isReady();\n            if (sceneIsReady) {\n                props.onSceneReady(scene);\n            } else {\n                scene.onReadyObservable.addOnce((scene) => {\n                    props.onSceneReady(scene);\n                    setSceneContext(() => ({\n                        canvas: reactCanvas.current,\n                        scene,\n                        engine,\n                        sceneReady: true,\n                    }));\n                });\n            }\n\n            engine.runRenderLoop(() => {\n                if (scene.activeCamera) {\n                    if (typeof onRender === 'function') {\n                        onRender(scene);\n                    }\n                    scene.render();\n                } else {\n                    // @babylonjs/core throws an error if you attempt to render with no active camera.\n                    // if we attach as a child React component we have frames with no active camera.\n                    console.warn('no active camera..');\n                }\n            })\n\n            const resize = () => {\n                scene.getEngine().resize();\n            }\n\n            if (window) {\n                window.addEventListener('resize', resize);\n            }\n\n            setSceneContext(() => ({\n                canvas: reactCanvas.current,\n                scene,\n                engine,\n                sceneReady: sceneIsReady,\n            }));\n\n            return () => {\n                scene.getEngine().dispose();\n\n                if (window) {\n                    window.removeEventListener('resize', resize);\n                }\n            }\n        }\n    }, [reactCanvas, adaptToDeviceRatio, antialias, engineOptions, onRender, props, sceneOptions]);\n\n    return (\n        <>\n            <canvas ref={reactCanvas} {...rest} />\n            <EngineCanvasContext.Provider value={engineContext}>\n                <SceneContext.Provider value={sceneContext}>\n                    {(renderChildrenWhenReady !== true || (renderChildrenWhenReady === true && sceneContext.sceneReady)) &&\n                        children\n                    }\n                </SceneContext.Provider>\n            </EngineCanvasContext.Provider>\n        </>\n    );\n}","import React, { FunctionComponent } from 'react';\nimport { Navbar, Nav } from 'react-bootstrap';\n\n/**\n * \n */\nexport const MenuBar: FunctionComponent<Readonly<{\n  onImport?: () => void;\n  onReplay?: () => void;\n}>> = ({ onImport, onReplay }) => {\n  const home = process.env.REACT_APP_BASENAME;\n  return (\n    <Navbar variant=\"dark\" bg=\"dark\" expand=\"lg\" >\n      <Navbar.Brand href=\"http://www.mmarini.org\">www.mmarini.org</Navbar.Brand>\n      <Navbar.Toggle aria-controls=\"navbar-nav\" />\n      <Navbar.Collapse id=\"navbar-nav\">\n        <Nav className=\"mr-auto\">\n          <Nav.Link href={home}>Rocket {process.env.REACT_APP_VERSION}</Nav.Link>\n          <Nav.Link onClick={() => { if (onImport) { onImport(); } }}>\n            Import\n          </Nav.Link>\n          <Nav.Link onClick={() => { if (onReplay) { onReplay(); } }}>\n            Replay\n          </Nav.Link>\n        </Nav>\n      </Navbar.Collapse>\n    </Navbar>\n  );\n}\n","import React, { Component } from 'react';\nimport { Modal, Button, Form } from 'react-bootstrap';\n\ninterface ImportFileProps {\n  show: boolean;\n  onCancel?: () => void\n  onFileRead?: (arg: string | ArrayBuffer | null) => void;\n  onError?: (arg: string) => void;\n};\n\n/**\n * \n */\nexport class ImportFile extends Component<ImportFileProps, {}>{\n\n  /**\n   * \n   * @param file \n   */\n  private onFileChange(file: Blob) {\n    const { onFileRead, onError } = this.props;\n    if (onFileRead) {\n      const fr = new FileReader();\n      fr.onload = (e) => {\n        onFileRead(fr.result);\n      };\n      fr.onerror = (event) => {\n        console.error(event);\n        if (onError) {\n          onError(event.toString());\n        }\n      };\n      try {\n        fr.readAsText(file);\n      } catch (e) {\n        console.error(e);\n        if (onError) {\n          onError(e.toString());\n        }\n      }\n    }\n  }\n\n  /**\n   * \n   */\n  render() {\n    const { show, onCancel } = this.props;\n    return (\n      <Modal size=\"lg\" show={show} onHide={() => { if (onCancel) { onCancel(); } }}>\n        <Modal.Header closeButton>\n          <Modal.Title>Import definitions from file ?</Modal.Title>\n        </Modal.Header>\n        <Modal.Body>\n          <p>The definitions will be imported from the selected file.</p>\n          <Form>\n            <Form.File\n              label=\"Import file\"\n              custom\n              onChange={(ev: any) => this.onFileChange(ev.target.files[0])}\n            />\n          </Form>\n        </Modal.Body>\n        <Modal.Footer>\n          <Button variant=\"primary\" onClick={() => { if (onCancel) { onCancel(); } }}>Cancel</Button>\n        </Modal.Footer>\n      </Modal >\n    );\n  }\n}\n","import {\n    Scene, HemisphericLight, MeshBuilder, Vector3, StandardMaterial, Texture,\n    CubeTexture, Color3, FollowCamera, UniversalCamera, Viewport, SceneLoader,\n    AbstractMesh, Skeleton, IParticleSystem\n} from \"@babylonjs/core\";\nimport { Container } from \"react-bootstrap\";\nimport { SceneComponent } from \"./SceneComponent\";\nimport '@babylonjs/loaders';\nimport { MenuBar } from \"./MenuBar\";\nimport { Component } from \"react\";\nimport { ImportFile } from \"./ImportFile\";\n\nconst MoonTextureUrl = '/rocket/texture/moon.jpg';\nconst PlatformTextureUrl = '/rocket/texture/platform.jpg';\nconst SkyBoxUrl = 'io/rocket/texture/skybox';\nconst RocketModelUrl = '/rocket/objs/';\nconst RocketFile = 'rocket.gltf';\nconst PlatformRatio = 480 / 360;\nconst PlatformSize = 20;\nconst Viewpoint = new Vector3(-20, 1.7, 40);\n\nconst Path = [\n    new Vector3(500, 150, 500),\n    new Vector3(250, 150, 250),\n    new Vector3(100, 100, 100),\n    new Vector3(20, 50, 30),\n    new Vector3(7, 10, -3),\n    new Vector3(-4, 0, 1)\n];\n\n/**\n * \n */\nclass SceneStatus {\n    private _t: number;\n    private _sampleInterval: number;\n    private _path: Vector3[] | undefined;\n\n    constructor() {\n        this._t = 0;\n        this._sampleInterval = 0;\n    }\n\n    get t() { return this._t; }\n\n    get sampleInterval() { return this._sampleInterval; }\n\n    get path() { return this._path; }\n\n    set t(t: number) { this._t = t; }\n\n    set sampleInterval(sampleInterval: number) {\n        this._sampleInterval = sampleInterval;\n        this._t = 0;\n    }\n\n    set path(path: Vector3[] | undefined) {\n        this._path = path;\n        this._t = 0;\n    }\n\n    /**\n     * \n    * @param t \n    * @param dt \n    * @param path \n    */\n    position() {\n        const { path, t, sampleInterval } = this;\n        if (!path) {\n            return Vector3.Zero();\n        }\n        const n = path.length;\n        const duration = (n - 1) * sampleInterval;\n        if (t >= duration) {\n            return path[n - 1];\n        } else {\n            const nt = t / sampleInterval;\n            const i = Math.floor(nt);\n            const dl = nt - i;\n            const p0 = path[i];\n            const p1 = path[i + 1];\n            const p01 = p1.subtract(p0);\n            const p = p01.scale(dl).add(p0);\n            return p;\n        }\n    }\n\n    /**\n     * \n     * @param dt \n     */\n    last(dt: number) {\n        this.t = this.t + dt;\n        return this;\n    }\n\n    reset() {\n        this._t = 0;\n    }\n}\n\n/**\n * \n * @param sampleInterval \n * @param path \n */\nfunction createStatus(sampleInterval: number, path?: Vector3[]) {\n    const status = new SceneStatus();\n    status.path = path;\n    status.sampleInterval = sampleInterval;\n    return status;\n}\n\nconst status = createStatus(30 / (Path.length - 1), Path);\n\n/**\n * \n * @param scene \n */\nfunction createCamera1(scene: Scene) {\n    const camera = new FollowCamera(\"camera1\", Viewpoint, scene);\n    camera.radius = 45;\n    camera.heightOffset = 1.7;\n    camera.cameraAcceleration = 0.01;\n    camera.maxCameraSpeed = 200 / 3.6;\n    return camera;\n}\n\n/**\n * \n * @param scene \n */\nfunction createCamera2(scene: Scene) {\n    const camera = new UniversalCamera('camera2', Viewpoint, scene);\n    camera.attachControl(true);\n    return camera;\n}\n\n/**\n * \n * @param scene \n */\nfunction loadRocket(scene: Scene) {\n    // The first parameter can be set to null to load all meshes and skeletons\n    SceneLoader.ImportMesh('10475_Rocket_Ship_v1_L3', RocketModelUrl, RocketFile, scene,\n        (meshes: AbstractMesh[], particles: IParticleSystem[], skeletons: Skeleton[]) => {\n            onRocketLoad(scene, meshes[0]);\n        });\n}\n\n/**\n * \n * @param scene \n * @param rocket \n */\nfunction onRocketLoad(scene: Scene, rocket: AbstractMesh) {\n    const camera1 = scene.getCameraByName('camera1') as (FollowCamera | null);\n    const camera2 = scene.getCameraByName('camera2') as (UniversalCamera | null);\n    if (camera1 && camera2) {\n        rocket.name = 'rocket';\n        camera1.lockedTarget = rocket;\n        camera2.lockedTarget = rocket;\n\n        // const light = scene.getLightByName('light');\n        // if (light) {\n        //     const shadowGenerator = new ShadowGenerator(1024, light as DirectionalLight);\n        //     shadowGenerator.addShadowCaster(rocket);\n        // }\n    }\n}\n\nfunction buildSkybox(scene: Scene) {\n    const skybox = MeshBuilder.CreateBox(\"skyBox\", { size: 1200 }, scene);\n    const skyboxMaterial = new StandardMaterial(\"skyBox\", scene);\n    skyboxMaterial.backFaceCulling = false;\n    skyboxMaterial.reflectionTexture = new CubeTexture(SkyBoxUrl, scene);\n    skyboxMaterial.reflectionTexture.coordinatesMode = Texture.SKYBOX_MODE;\n    skyboxMaterial.diffuseColor = new Color3(0, 0, 0);\n    skyboxMaterial.specularColor = new Color3(0, 0, 0);\n    skybox.material = skyboxMaterial;\n    return skybox;\n}\n\n/**\n * \n * @param scene \n */\nfunction buildGround(scene: Scene) {\n    // Texture\n    const groundMat = new StandardMaterial(\"groundMat\", scene);\n    groundMat.diffuseTexture = new Texture(MoonTextureUrl, scene);\n\n    // Our built-in 'ground' shape.\n    const ground = MeshBuilder.CreateGround(\"ground\", { width: 1000, height: 1000, subdivisions: 2 }, scene);\n    ground.material = groundMat;\n    ground.position.y = -0.01;\n    // ground.receiveShadows = true;\n    return ground;\n}\n\n/**\n * \n * @param scene \n */\nfunction buildPlatform(scene: Scene) {\n    // Texture\n    const platMat = new StandardMaterial(\"platMat\", scene);\n    platMat.diffuseTexture = new Texture(PlatformTextureUrl, scene);\n\n    // Our built-in 'ground' shape.\n    const platform = MeshBuilder.CreateGround(\"platform\", {\n        width: PlatformSize * PlatformRatio,\n        height: PlatformSize * PlatformRatio,\n        subdivisions: 2\n    }, scene);\n    platform.material = platMat;\n    platform.receiveShadows = true;\n    return platform;\n}\n\n/**\n * \n * @param scene \n */\nfunction buildLights(scene: Scene) {\n    // This creates a light, aiming 0,1,0 - to the sky (non-mesh)\n    const light = new HemisphericLight(\"light\", new Vector3(1, 1, 0), scene);\n    // const light = new DirectionalLight(\"light\", new Vector3(1, -1, -1), scene);\n    // Default intensity is 1. Let's dim the light a small amount\n    light.intensity = 1;\n    return light;\n}\n\n/**\n * \n * @param scene \n */\nfunction onSceneReady(scene: Scene) {\n    const camera = createCamera1(scene);\n    const camera2 = createCamera2(scene);\n    camera.viewport = new Viewport(0, 0, 0.5, 1.0);\n    camera2.viewport = new Viewport(0.5, 0, 0.5, 1.0);\n\n    scene.activeCameras?.push(camera);\n    scene.activeCameras?.push(camera2);\n\n    buildLights(scene);\n    buildGround(scene);\n    buildPlatform(scene);\n    buildSkybox(scene);\n    loadRocket(scene);\n}\n\n/**\n * \n * @param scene \n */\nfunction onRender(scene: Scene) {\n    const dt1 = scene.getEngine().getDeltaTime() / 1000;\n    status.last(dt1);\n    const rocket = scene.getMeshByName('rocket');\n    if (rocket) {\n        rocket.position = status.position();\n    }\n}\n\n/**\n * \n */\nexport class Home extends Component<{}, {\n    importModalShown: boolean\n}>{\n\n    /**\n     * \n     * @param props \n     */\n    constructor(props: {}) {\n        super(props);\n        this.state = {\n            importModalShown: false\n        };\n    }\n\n    /**\n     * \n     */\n    private showImportPanel() {\n        this.setState({ importModalShown: true });\n    }\n\n    /**\n     * \n     */\n    private onImportCancel() {\n        this.setState({ importModalShown: false });\n    }\n\n    /**\n     * \n     * @param data \n     */\n    private onImportFile(data: string | ArrayBuffer | null) {\n        console.log(data);\n        this.setState({ importModalShown: false });\n    }\n\n    /**\n     * \n     * @param error \n     */\n    private onImportError(error: string) {\n        console.error(error);\n        this.setState({ importModalShown: false });\n    }\n\n    render() {\n        const { importModalShown } = this.state;\n        return (\n            <Container fluid>\n                <MenuBar\n                    onImport={() => this.showImportPanel()}\n                    onReplay={() => status.reset()}\n                />\n                <Container fluid>\n                    <SceneComponent antialias\n                        width={1400}\n                        height={640}\n                        onSceneReady={onSceneReady}\n                        onRender={scene => { onRender(scene) }}\n                        id='rocket-canvas' />\n                </Container>\n                <ImportFile show={importModalShown}\n                    onCancel={() => { this.onImportCancel() }}\n                    onFileRead={data => this.onImportFile(data)}\n                    onError={e => this.onImportError(e)} />\n            </Container>\n        );\n    }\n}\n","import './App.css';\nimport { Home } from './modules/Home';\n\nfunction App() {\n  return (\n    <Home/>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}