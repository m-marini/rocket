{"version":3,"sources":["modules/SceneComponent.tsx","modules/MenuBar.tsx","modules/ImportFile.tsx","modules/Home.tsx","modules/position-reader.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["SceneComponent","props","reactCanvas","useRef","antialias","engineOptions","adaptToDeviceRatio","sceneOptions","onRender","renderChildrenWhenReady","onSceneReady","children","rest","useState","scene","sceneReady","sceneContext","setSceneContext","engine","canvas","engineContext","setEngineContext","useEffect","current","Engine","Scene","sceneIsReady","isReady","onReadyObservable","addOnce","runRenderLoop","activeCamera","render","console","warn","resize","getEngine","window","addEventListener","dispose","removeEventListener","ref","Provider","value","MenuBar","onImport","onReplay","Navbar","variant","bg","expand","Brand","href","Toggle","aria-controls","Collapse","id","Nav","className","Link","homepage","version","onClick","ImportFile","show","onCancel","onSelect","Modal","size","onHide","Header","closeButton","Title","Body","Form","File","label","custom","onChange","ev","file","target","files","from","text","Footer","Button","hud","WebContext","MoonTextureUrl","PlatformTextureUrl","SkyBoxUrl","RocketModelUrl","SampleUrl","PlatformRatio","Viewpoint","Vector3","interpolateV3","p0","p1","alpha","subtract","scale","add","SceneStatus","_t","_sampleInterval","_path","this","x","interpolate","position","to","Zero","speed","status","fuel","path","t","sampleInterval","n","length","nt","i","Math","floor","dt","createStatus","camera","FollowCamera","radius","heightOffset","cameraAcceleration","maxCameraSpeed","createCamera1","camera2","UniversalCamera","attachControl","createCamera2","viewport","Viewport","activeCameras","push","advancedTexture","AdvancedDynamicTexture","CreateFullscreenUI","undefined","text1","TextBlock","color","width","height","fontFamily","fontSize","horizontalAlignment","Control","HORIZONTAL_ALIGNMENT_LEFT","verticalAlignment","VERTICAL_ALIGNMENT_TOP","textHorizontalAlignment","paddingLeftInPixels","addControl","buildHud","light","HemisphericLight","intensity","buildLights","groundMat","StandardMaterial","diffuseTexture","Texture","ground","MeshBuilder","CreateGround","subdivisions","material","y","buildGround","platMat","platform","receiveShadows","buildPlatform","skybox","CreateBox","skyboxMaterial","backFaceCulling","reflectionTexture","CubeTexture","coordinatesMode","SKYBOX_MODE","diffuseColor","Color3","specularColor","buildSkybox","SceneLoader","ImportMesh","meshes","particles","skeletons","rocket","camera1","getCameraByName","name","lockedTarget","onRocketLoad","loadRocket","dt1","getDeltaTime","last","getMeshByName","d","sqrt","z","dirpn","atan2","PI","dir","round","vh","vdirpn","vdir","txt","sprintf","renderHud","positionVectors","obs","pipe","flatMap","split","filter","map","line","parseFloat","data","toArray","Home","state","importModalShown","ajax","url","responseType","response","importFile","setState","tap","onPathReady","err","onImportError","subscribe","error","Container","fluid","showImportPanel","reset","onImportCancel","onImportFile","Component","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.2933a032.chunk.js","sourcesContent":["import React, { useEffect, useContext, useRef, useState, FunctionComponent } from 'react';\nimport { Engine, Scene, Nullable, EngineOptions, SceneOptions, EventState, Observer, Camera } from '@babylonjs/core';\nimport { EngineCanvasContext, EngineCanvasContextType, SceneContext, SceneContextType } from 'babylonjs-hook';\nimport '../App.css';\n\nexport type BabylonjsProps = {\n    antialias?: boolean\n    engineOptions?: EngineOptions\n    adaptToDeviceRatio?: boolean\n    renderChildrenWhenReady?: boolean\n    sceneOptions?: SceneOptions\n    onSceneReady: (scene: Scene) => void\n    onRender?: (scene: Scene) => void\n    id: string\n    children?: React.ReactNode\n    width?: number;\n    height?: number;\n};\n\nexport type OnFrameRenderFn = (eventData: Scene, eventState: EventState) => void\n\n/**\n * Register a callback for before the scene renders.\n * \n * @param callback called using onBeforeRender functionality of scene\n * @param mask the mask used to filter observers\n * @param insertFirst if true will be inserted at first position, if false (default) will be last position.\n * @param callOnce only call the callback once\n */\nexport const useBeforeRender = (callback: OnFrameRenderFn, mask?: number, insertFirst?: boolean, callOnce?: boolean): void => {\n    const { scene } = useContext(SceneContext);\n\n    useEffect(() => {\n        if (scene === null) {\n            return;\n        }\n\n        const unregisterOnFirstCall: boolean = callOnce === true;\n        const sceneObserver: Nullable<Observer<Scene>> = scene.onBeforeRenderObservable.add(callback, mask, insertFirst, undefined, unregisterOnFirstCall);\n\n        if (unregisterOnFirstCall !== true) {\n            return () => {\n                scene.onBeforeRenderObservable.remove(sceneObserver);\n            }\n        }\n    })\n}\n\n/**\n * Register a callback for after the scene renders.\n * \n * @param callback called using onBeforeRender functionality of scene\n * @param mask the mask used to filter observers\n * @param insertFirst if true will be inserted at first position, if false (default) will be last position.\n * @param callOnce only call the callback once\n */\nexport const useAfterRender = (callback: OnFrameRenderFn, mask?: number, insertFirst?: boolean, callOnce?: boolean): void => {\n    const { scene } = useContext(SceneContext);\n\n    useEffect(() => {\n        if (scene === null) {\n            return;\n        }\n\n        const unregisterOnFirstCall: boolean = callOnce === true;\n        const sceneObserver: Nullable<Observer<Scene>> = scene.onAfterRenderObservable.add(callback, mask, insertFirst, undefined, unregisterOnFirstCall);\n\n        if (unregisterOnFirstCall !== true) {\n            return () => {\n                scene.onAfterRenderObservable.remove(sceneObserver);\n            }\n        }\n    })\n}\n\n/**\n * Handles creating a camera and attaching/disposing.\n * TODO: add new 4.2 parameters: useCtrlForPanning & panningMouseButton\n * @param createCameraFn function that creates and returns a camera\n * @param autoAttach Attach the input controls (default true)\n * @param noPreventDefault Events caught by controls should call prevent default\n */\nexport const useCamera = <T extends Camera>(createCameraFn: (scene: Scene) => T, autoAttach: boolean = true, noPreventDefault: boolean = true): Nullable<T> => {\n    const { scene } = useContext(SceneContext);\n    const cameraRef = useRef<Nullable<T>>(null);\n\n    useEffect(() => {\n        if (scene === null) {\n            console.warn('cannot create camera (scene not ready)');\n            return;\n        }\n\n        const camera = createCameraFn(scene);\n        if (autoAttach === true) {\n            const canvas: HTMLCanvasElement = scene.getEngine()!.getRenderingCanvas()!;\n\n            // This attaches the camera to the canvas\n            // https://github.com/BabylonJS/Babylon.js/pull/9192 (keep canvas to work with < 4.2 beta-13)\n            (camera as any).attachControl(canvas, noPreventDefault);\n        }\n        cameraRef.current = camera;\n\n        return () => {\n            if (autoAttach === true) {\n                const canvas: HTMLCanvasElement = scene.getEngine()!.getRenderingCanvas()!;\n                (camera as any).detachControl(canvas);\n            }\n            camera.dispose();\n        }\n    }, [scene, autoAttach, createCameraFn, noPreventDefault]);\n\n    return cameraRef.current;\n}\n\nexport const SceneComponent: FunctionComponent<BabylonjsProps> = props => {\n    const reactCanvas = useRef<Nullable<HTMLCanvasElement>>(null);\n    const { antialias, engineOptions, adaptToDeviceRatio, sceneOptions, onRender, onSceneReady, renderChildrenWhenReady, children, ...rest } = props;\n\n    const [sceneContext, setSceneContext] = useState<SceneContextType>({\n        scene: null,\n        sceneReady: false\n    });\n\n    const [engineContext, setEngineContext] = useState<EngineCanvasContextType>({\n        engine: null,\n        canvas: null\n    });\n\n    useEffect(() => {\n        if (reactCanvas.current) {\n            const engine = new Engine(reactCanvas.current, antialias, engineOptions, adaptToDeviceRatio);\n            setEngineContext(() => ({\n                engine,\n                canvas: reactCanvas.current\n            }));\n\n            const scene = new Scene(engine, sceneOptions);\n            const sceneIsReady = scene.isReady();\n            if (sceneIsReady) {\n                props.onSceneReady(scene);\n            } else {\n                scene.onReadyObservable.addOnce((scene) => {\n                    props.onSceneReady(scene);\n                    setSceneContext(() => ({\n                        canvas: reactCanvas.current,\n                        scene,\n                        engine,\n                        sceneReady: true,\n                    }));\n                });\n            }\n\n            engine.runRenderLoop(() => {\n                if (scene.activeCamera) {\n                    if (typeof onRender === 'function') {\n                        onRender(scene);\n                    }\n                    scene.render();\n                } else {\n                    // @babylonjs/core throws an error if you attempt to render with no active camera.\n                    // if we attach as a child React component we have frames with no active camera.\n                    console.warn('no active camera..');\n                }\n            })\n\n            const resize = () => {\n                scene.getEngine().resize();\n            }\n\n            if (window) {\n                window.addEventListener('resize', resize);\n            }\n\n            setSceneContext(() => ({\n                canvas: reactCanvas.current,\n                scene,\n                engine,\n                sceneReady: sceneIsReady,\n            }));\n\n            return () => {\n                scene.getEngine().dispose();\n\n                if (window) {\n                    window.removeEventListener('resize', resize);\n                }\n            }\n        }\n    }, [reactCanvas, adaptToDeviceRatio, antialias, engineOptions, onRender, props, sceneOptions]);\n\n    return (\n        <>\n            <canvas ref={reactCanvas} {...rest} />\n            <EngineCanvasContext.Provider value={engineContext}>\n                <SceneContext.Provider value={sceneContext}>\n                    {(renderChildrenWhenReady !== true || (renderChildrenWhenReady === true && sceneContext.sceneReady)) &&\n                        children\n                    }\n                </SceneContext.Provider>\n            </EngineCanvasContext.Provider>\n        </>\n    );\n}","import React, { FunctionComponent } from 'react';\nimport { Navbar, Nav } from 'react-bootstrap';\nimport {version, homepage} from '../../package.json';\n\n/**\n * \n */\nexport const MenuBar: FunctionComponent<Readonly<{\n  onImport?: () => void;\n  onReplay?: () => void;\n}>> = ({ onImport, onReplay }) => {\n  return (\n    <Navbar variant=\"dark\" bg=\"dark\" expand=\"lg\" >\n      <Navbar.Brand href=\"http://www.mmarini.org\">www.mmarini.org</Navbar.Brand>\n      <Navbar.Toggle aria-controls=\"navbar-nav\" />\n      <Navbar.Collapse id=\"navbar-nav\">\n        <Nav className=\"mr-auto\">\n          <Nav.Link href={homepage}>Rocket {version}</Nav.Link>\n          <Nav.Link onClick={() => { if (onImport) { onImport(); } }}>\n            Import\n          </Nav.Link>\n          <Nav.Link onClick={() => { if (onReplay) { onReplay(); } }}>\n            Replay\n          </Nav.Link>\n        </Nav>\n      </Navbar.Collapse>\n    </Navbar>\n  );\n}\n","import React, { FunctionComponent } from 'react';\nimport { Modal, Button, Form } from 'react-bootstrap';\nimport { from, Observable } from 'rxjs';\n\ninterface ImportFileProps {\n  show: boolean;\n  onCancel?: () => void\n  onSelect?: (arg: Observable<string>) => void;\n};\n\n/**\n * \n */\nexport const ImportFile: FunctionComponent<ImportFileProps> = ({ show, onCancel, onSelect }) => {\n\n  function onFileChange(file: Blob) {\n    if (onSelect) {\n      onSelect(from(file.text()));\n    }\n  }\n\n  return (\n    <Modal size=\"lg\" show={show} onHide={() => { if (onCancel) { onCancel(); } }}>\n      <Modal.Header closeButton>\n        <Modal.Title>Import definitions from file ?</Modal.Title>\n      </Modal.Header>\n      <Modal.Body>\n        <p>The definitions will be imported from the selected file.</p>\n        <Form>\n          <Form.File\n            label=\"Import file\"\n            custom\n            onChange={(ev: any) => onFileChange(ev.target.files[0])}\n          />\n        </Form>\n      </Modal.Body>\n      <Modal.Footer>\n        <Button variant=\"primary\" onClick={() => { if (onCancel) { onCancel(); } }}>Cancel</Button>\n      </Modal.Footer>\n    </Modal >\n  );\n}\n","import {\n    Scene, HemisphericLight, MeshBuilder, Vector3, StandardMaterial, Texture,\n    CubeTexture, Color3, FollowCamera, UniversalCamera, Viewport, SceneLoader,\n    AbstractMesh, Skeleton, IParticleSystem\n} from \"@babylonjs/core\";\nimport { Container } from \"react-bootstrap\";\nimport { SceneComponent } from \"./SceneComponent\";\nimport '@babylonjs/loaders';\nimport { AdvancedDynamicTexture, TextBlock, Control } from 'babylonjs-gui';\nimport { MenuBar } from \"./MenuBar\";\nimport { Component } from \"react\";\nimport { ImportFile } from \"./ImportFile\";\nimport { homepage } from '../../package.json';\nimport { filter, map, tap, toArray } from 'rxjs/operators';\nimport { Observable } from \"rxjs\";\nimport { ajax } from 'rxjs/ajax';\nimport { csv, lines } from \"./position-reader\";\nimport { sprintf } from 'sprintf-js';\n\nconst WebContext = homepage;\nconst MoonTextureUrl = `/${WebContext}/texture/moon.jpg`;\nconst PlatformTextureUrl = `/${WebContext}/texture/platform.jpg`;\nconst SkyBoxUrl = `/${WebContext}/texture/skybox`;\nconst RocketModelUrl = `/${WebContext}/objs/`;\nconst RocketFile = 'rocket.gltf';\nconst SampleUrl = `/${WebContext}/sample.csv`;\nconst PlatformRatio = 480 / 360;\nconst PlatformSize = 20;\nconst Viewpoint = new Vector3(-20, 1.7, 40);\n\nconst SampleInterval = 0.25;\n\nvar hud: TextBlock | undefined;\n\ntype Status = {\n    position: Vector3;\n    speed: Vector3;\n    fuel: number;\n    status: number;\n}\n\nfunction interpolateV3(p0: Vector3, p1: Vector3, alpha: number) {\n    const p01 = p1.subtract(p0);\n    const p = p01.scale(alpha).add(p0);\n    return p;\n}\n\n/**\n * \n */\nclass SceneStatus {\n    private _t: number;\n    private _sampleInterval: number;\n    private _path: Status[] | undefined;\n\n    constructor() {\n        this._t = 0;\n        this._sampleInterval = SampleInterval;\n    }\n\n    get t() { return this._t; }\n\n    get sampleInterval() { return this._sampleInterval; }\n\n    get path() { return this._path; }\n\n    set t(t: number) { this._t = t; }\n\n    set sampleInterval(sampleInterval: number) {\n        this._sampleInterval = sampleInterval;\n        this._t = 0;\n    }\n\n    set path(path: Status[] | undefined) {\n        this._path = path;\n        this._t = 0;\n    }\n\n    /**\n     * \n     * @returns \n     */\n    position() {\n        const x = this.interpolate();\n        if (!!x) {\n            return interpolateV3(x.from.position, x.to.position, x.alpha);\n        } else {\n            return Vector3.Zero();\n        }\n    }\n\n    /**\n     * \n     * @returns \n     */\n    speed() {\n        const x = this.interpolate();\n        if (!!x) {\n            return interpolateV3(x.from.speed, x.to.speed, x.alpha);\n        } else {\n            return Vector3.Zero();\n        }\n    }\n\n    status() {\n        const x = this.interpolate();\n        if (!!x) {\n            return x.from.status;\n        } else {\n            return 0;\n        }\n    }\n\n    fuel() {\n        const x = this.interpolate();\n        if (!!x) {\n            return (x.to.fuel-x.from.fuel) * x.alpha + x.from.fuel;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * \n     * @param idx \n     * @returns \n     */\n    interpolate() {\n        const { path, t, sampleInterval } = this;\n        if (!path) {\n            return undefined;\n        }\n        const n = path.length;\n        const duration = (n - 1) * sampleInterval;\n        if (t >= duration) {\n            return { from: path[n - 1], to: path[n - 1], alpha: 0 };\n        } else {\n            const nt = t / sampleInterval;\n            const i = Math.floor(nt);\n            const alpha = nt - i;\n            const from = path[i];\n            const to = path[i + 1];\n            return { from, to, alpha };\n        }\n    }\n\n    /**\n     * \n     * @param dt \n     */\n    last(dt: number) {\n        this.t = this.t + dt;\n        return this;\n    }\n\n    reset() {\n        this._t = 0;\n    }\n}\n\n/**\n * \n * @param sampleInterval \n * @param path \n */\nfunction createStatus(sampleInterval: number, path?: Status[]) {\n    const status = new SceneStatus();\n    status.path = path;\n    status.sampleInterval = sampleInterval;\n    return status;\n}\n\nconst status = createStatus(SampleInterval);\n\n/**\n * \n * @param scene \n */\nfunction createCamera1(scene: Scene) {\n    const camera = new FollowCamera(\"camera1\", Viewpoint, scene);\n    camera.radius = 45;\n    camera.heightOffset = 1.7;\n    camera.cameraAcceleration = 0.01;\n    camera.maxCameraSpeed = 200 / 3.6;\n    return camera;\n}\n\n/**\n * \n * @param scene \n */\nfunction createCamera2(scene: Scene) {\n    const camera = new UniversalCamera('camera2', Viewpoint, scene);\n    camera.attachControl(true);\n    return camera;\n}\n\n/**\n * \n * @param scene \n */\nfunction loadRocket(scene: Scene) {\n    // The first parameter can be set to null to load all meshes and skeletons\n    SceneLoader.ImportMesh('10475_Rocket_Ship_v1_L3', RocketModelUrl, RocketFile, scene,\n        (meshes: AbstractMesh[], particles: IParticleSystem[], skeletons: Skeleton[]) => {\n            onRocketLoad(scene, meshes[0]);\n        });\n}\n\n/**\n * \n * @param scene \n * @param rocket \n */\nfunction onRocketLoad(scene: Scene, rocket: AbstractMesh) {\n    const camera1 = scene.getCameraByName('camera1') as (FollowCamera | null);\n    const camera2 = scene.getCameraByName('camera2') as (UniversalCamera | null);\n    if (camera1 && camera2) {\n        rocket.name = 'rocket';\n        camera1.lockedTarget = rocket;\n        camera2.lockedTarget = rocket;\n    }\n}\n\nfunction buildSkybox(scene: Scene) {\n    const skybox = MeshBuilder.CreateBox(\"skyBox\", { size: 1200 }, scene);\n    const skyboxMaterial = new StandardMaterial(\"skyBox\", scene);\n    skyboxMaterial.backFaceCulling = false;\n    skyboxMaterial.reflectionTexture = new CubeTexture(SkyBoxUrl, scene);\n    skyboxMaterial.reflectionTexture.coordinatesMode = Texture.SKYBOX_MODE;\n    skyboxMaterial.diffuseColor = new Color3(0, 0, 0);\n    skyboxMaterial.specularColor = new Color3(0, 0, 0);\n    skybox.material = skyboxMaterial;\n    return skybox;\n}\n\n/**\n * \n * @param scene \n */\nfunction buildGround(scene: Scene) {\n    // Texture\n    const groundMat = new StandardMaterial(\"groundMat\", scene);\n    groundMat.diffuseTexture = new Texture(MoonTextureUrl, scene);\n\n    // Our built-in 'ground' shape.\n    const ground = MeshBuilder.CreateGround(\"ground\", { width: 1000, height: 1000, subdivisions: 2 }, scene);\n    ground.material = groundMat;\n    ground.position.y = -0.01;\n    // ground.receiveShadows = true;\n    return ground;\n}\n\n/**\n * \n * @param scene \n */\nfunction buildHud(scene: Scene) {\n    const advancedTexture = AdvancedDynamicTexture.CreateFullscreenUI(\"GUI\", undefined, scene);\n    const text1 = new TextBlock(\"HUD\");\n    text1.color = \"white\";\n    text1.width = \"250px\";\n    text1.height = \"100px\";\n    text1.fontFamily = \"monospace\";\n    text1.fontSize = 20;\n    // text1.color = \"#00ffff\"\n    text1.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\n    text1.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;\n    text1.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\n    text1.paddingLeftInPixels = 10;\n    advancedTexture.addControl(text1);\n    return text1;\n}\n\n/**\n * \n * @param scene \n */\nfunction buildPlatform(scene: Scene) {\n    // Texture\n    const platMat = new StandardMaterial(\"platMat\", scene);\n    platMat.diffuseTexture = new Texture(PlatformTextureUrl, scene);\n\n    // Our built-in 'ground' shape.\n    const platform = MeshBuilder.CreateGround(\"platform\", {\n        width: PlatformSize * PlatformRatio,\n        height: PlatformSize * PlatformRatio,\n        subdivisions: 2\n    }, scene);\n    platform.material = platMat;\n    platform.receiveShadows = true;\n    return platform;\n}\n\n/**\n * \n * @param scene \n */\nfunction buildLights(scene: Scene) {\n    // This creates a light, aiming 0,1,0 - to the sky (non-mesh)\n    const light = new HemisphericLight(\"light\", new Vector3(1, 1, 0), scene);\n    // const light = new DirectionalLight(\"light\", new Vector3(1, -1, -1), scene);\n    // Default intensity is 1. Let's dim the light a small amount\n    light.intensity = 1;\n    return light;\n}\n\n/**\n * \n * @param scene \n */\nfunction onSceneReady(scene: Scene) {\n    const camera = createCamera1(scene);\n    const camera2 = createCamera2(scene);\n    camera.viewport = new Viewport(0, 0, 0.5, 1.0);\n    camera2.viewport = new Viewport(0.5, 0, 0.5, 1.0);\n\n    scene.activeCameras?.push(camera);\n    scene.activeCameras?.push(camera2);\n\n    hud = buildHud(scene);\n    buildLights(scene);\n    buildGround(scene);\n    buildPlatform(scene);\n    buildSkybox(scene);\n    loadRocket(scene);\n}\n\nfunction renderHud(hud: TextBlock | undefined, status: SceneStatus) {\n    if (!!hud) {\n        const position = status.position();\n        const d = Math.sqrt(position.x * position.x + position.z * position.z);\n        const dirpn = 180 * Math.atan2(position.x, position.z) / Math.PI;\n        const dir = Math.round(dirpn > 0 ? dirpn : dirpn + 360);\n\n        const speed = status.speed();\n        const vh = Math.sqrt(speed.x * speed.x + speed.z * speed.z);\n        const vdirpn = 180 * Math.atan2(speed.x, speed.z) / Math.PI;\n        const vdir = Math.round(vdirpn > 0 ? vdirpn : vdirpn + 360);\n\n        const txt = sprintf('Pos   %05.1f %03d %05.1f\\nSpeed %03.1f %03d %+03.1f\\nFuel  %05.1f',\n            d, dir, position.y,\n            vh, vdir, speed.y,\n            status.fuel());\n        hud.text = txt;\n    }\n    return hud;\n}\n\n/**\n * \n * @param scene \n */\nfunction onRender(scene: Scene) {\n    const dt1 = scene.getEngine().getDeltaTime() / 1000;\n    status.last(dt1);\n    const rocket = scene.getMeshByName('rocket');\n    if (rocket) {\n        rocket.position = status.position();\n    }\n    renderHud(hud, status);\n}\n\n/**\n * \n * @returns \n */\nfunction toStatus() {\n    return map((data: number[]) => {\n        return {\n            position: new Vector3(data[0], data[2], data[1]),\n            speed: new Vector3(data[3], data[5], data[4]),\n            fuel: data[6],\n            status: data[8]\n        };\n    });\n}\n\nfunction positionVectors() {\n    return (obs: Observable<string>) => obs.pipe(\n        lines(),\n        filter(text => !!text),\n        csv(),\n        toStatus(),\n        toArray()\n    );\n}\n\n/**\n * \n */\nexport class Home extends Component<{}, {\n    importModalShown: boolean\n}>{\n\n    /**\n     * \n     * @param props \n     */\n    constructor(props: {}) {\n        super(props);\n        this.state = {\n            importModalShown: false\n        };\n    }\n\n    componentDidMount() {\n        const obs = ajax({\n            url: SampleUrl,\n            responseType: 'text'\n        }).pipe(\n            map(data => data.response),\n        );\n        this.importFile(obs);\n\n    }\n\n    /**\n     * \n     */\n    private showImportPanel() {\n        this.setState({ importModalShown: true });\n    }\n\n    /**\n     * \n     */\n    private onImportCancel() {\n        this.setState({ importModalShown: false });\n    }\n\n    private importFile(data: Observable<string>) {\n        data.pipe(\n            positionVectors(),\n            tap(\n                data => this.onPathReady(data),\n                err => this.onImportError(err)\n            )\n        ).subscribe();\n    }\n\n    /**\n     * \n     * @param data \n     */\n    private onImportFile(data: Observable<string>) {\n        this.setState({ importModalShown: false });\n        this.importFile(data);\n    }\n\n    private onPathReady(path: Status[]) {\n        status.path = path;\n    }\n    /**\n     * \n     * @param error \n     */\n    private onImportError(error: any) {\n        console.error(error);\n    }\n\n    render() {\n        const { importModalShown } = this.state;\n        return (\n            <Container fluid>\n                <MenuBar\n                    onImport={() => this.showImportPanel()}\n                    onReplay={() => status.reset()}\n                />\n                <Container fluid>\n                    <SceneComponent antialias\n                        width={1400}\n                        height={640}\n                        onSceneReady={onSceneReady}\n                        onRender={scene => { onRender(scene) }}\n                        id='rocket-canvas' />\n                </Container>\n                <ImportFile show={importModalShown}\n                    onCancel={() => { this.onImportCancel() }}\n                    onSelect={obs => this.onImportFile(obs)} />\n            </Container>\n        );\n    }\n}\n","import { from } from \"rxjs\";\nimport { flatMap, map } from \"rxjs/operators\";\nimport { Vector3 } from \"@babylonjs/core\";\n\n/**\n * \n * @param line \n */\nexport function vector3(offset: number) {\n    return map((data: number[]) => new Vector3(data[offset], data[offset + 2], data[offset + 1]));\n}\n\n/**\n * \n * @param offsets \n * @returns \n */\nexport function vectors3(offsets: number[]) {\n    return map((data: number[]) =>\n        offsets.map(i =>\n            new Vector3(data[i], data[i + 2], data[i + 1])\n        )\n    );\n}\n\n/**\n * \n */\nexport function csv() {\n    return map((line: string) => line.split(',').map(parseFloat));\n}\n\n/**\n * \n */\nexport function lines() {\n    return flatMap((text: string) => from(text.split(/\\r\\n|\\n/)))\n}\n","import './App.css';\nimport { Home } from './modules/Home';\n\nfunction App() {\n  return (\n    <Home/>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}